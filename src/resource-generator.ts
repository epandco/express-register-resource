import 'reflect-metadata';

import * as express from 'express';
import * as pino from 'express-pino-logger';
import { Container } from 'inversify';
import { pinoLogLevel } from './config';
import { ResourceHandler, ResourceRequest } from './resource-handler';
import { resourceHandlerFactory } from './resource-handler-factory';
import { ResourceRouteMetadata, ResourceType, getDefaultRenderer } from 'resource-decorator';
import { resourceErrorHandler } from './resource-error-handler';
import { Response } from 'express-serve-static-core';

const pinoMiddleware = pino({
  level: pinoLogLevel
});

function getMetadataByKey(key: string, resource: Resource): any {
  return Reflect.getMetadata(key, resource.prototype);
}

function getMetadataKeys(resource: Resource): string[] {
  return Reflect.getMetadataKeys(resource.prototype);
}

/**
 * Takes type T that has been decorated as a resource and
 * generates an epxress router with the various routes defined
 * in the decorated resource.
 * 
 * The routes generated by this class will create a new instance of type T
 * each time a request comes in. Inversify is used to resolve an instance of type T
 * so it's important specificy a container in the constructor.
 * 
 * @throws Error if the resource is not decorated correctly.
 */

type Resource =  { new (...args: any[]): any};

export class ResourceGenerator {

  /**
   * Generates an express router that represents the resource defined by type T
   */
  register(app: express.Application, resource: Resource, container: Container ): void {
    const routeKeys = getMetadataKeys(resource).filter((md: string) => md.startsWith('route-'));
    const resourceName = resource.name;
    const genVersion = getMetadataByKey(
      'resource-generator-version',
      resource
    );

    if (!genVersion) {
      throw Error(`${resourceName} is missing the resource decorator. Please check that the class has the decorator on it`);
    }
    else if (genVersion != 'v1') {
      throw Error(`${resourceName} was generated with an incompatible version of the resource-generator. Expected v1 and got ${genVersion}`);
    }

    console.log(`Generating resource: ${resourceName}`);

    let basePath: string | null | undefined = getMetadataByKey(
      'base-path',
      resource
    );

    if (basePath) {
      console.log(`    base path: ${basePath}`);
    }
    else {
      basePath = '';
    }

    const router = express.Router();
    const resourceMiddleware: ResourceHandler[] = getMetadataByKey(
      'express-resource-middleware',
      resource
    );

    for (const key of routeKeys) {
      const route: ResourceRouteMetadata = getMetadataByKey(key, resource);
      const routeMiddleware: ResourceHandler[] = getMetadataByKey(
        `express-route-middleware-${route.methodKey}`,
        resource
      );

      console.log(`    adding route: ${route.resourceType} ${route.method.toUpperCase()} ${route.path}`);

      /**
       * 
       * middleware will stack like this per route
       * 
       * | JSON Body parser           | <- If applicable to route
       * | Inject Renderer for Route  |
       * | Resource level Middleware  |
       * | Route level Middleware     |
       * | Generated resource Wrapper | <- Always the last function in the chain for a route
       * | Resource error handler     | <- Always the last function in the chain for a route
       *
       */ 
      const middleware: ResourceHandler[] = [pinoMiddleware];

      if (route.resourceType == ResourceType.API) {
       // Coercing the type express.json middleware here into the ResourceHandler type
       // this should be ok as the signatures match. ResourceRequest is just a normal Express Request.
        middleware.push(express.json() as ResourceHandler);
      }

      if (!route.resourceRenderer) {
        // Get default ResourceRenderer for this resourceType if none is passed in.
        // This will likely be the the normal case.
        route.resourceRenderer = getDefaultRenderer(route.resourceType);
      }

      const injectRouteRenderer = (req: ResourceRequest, resp: Response, next: Function): void => {
        try {
          req.local._renderer = route.resourceRenderer;
          next();
        }
        catch (error) {
          req.log.fatal(error, 'Unable to set renderer for the router');
          resp.status(500).send('fatal error check logs');
        }
      };

      // First thing we do is attach the route renderer to the request
      // if this were to throw an error we would not know what type to handle
      // but it SHOULD NEVER throw an error
      resourceMiddleware.push(injectRouteRenderer);

      if (resourceMiddleware) {
        middleware.push(...resourceMiddleware);
      }

      if (routeMiddleware) {
        middleware.push(...routeMiddleware);
      }

      let resourceHandler;
      switch (route.resourceType) {
        case ResourceType.API:
        case ResourceType.TEMPLATE:
          resourceHandler = resourceHandlerFactory(route, resource, container);
          break;
        case ResourceType.FILE:
          throw new Error('File render types not supported yet');
          break;
        default:
          throw new Error('Unexpected render type');
      }
      middleware.push(resourceHandler);

      router[route.method](route.path, ...middleware);
    }

    router.use(resourceErrorHandler);
    app.use(basePath, router);
  }
}