import 'reflect-metadata';

import * as express from 'express';
import * as pino from 'express-pino-logger';
import { Container } from 'inversify';
import { pinoLogLevel } from './config';
import { ResourceHandler } from './resource-handler';
import { templateHandler } from './template-handler';
import { apiHandler } from './api-handler';
import { ResourceRouteMetadata, ResourceType, getDefaultRenderer } from 'resource-decorator';

const pinoMiddleware = pino({
  level: pinoLogLevel
});

/**
 * Takes type T that has been decorated as a resource and
 * generates an epxress router with the various routes defined
 * in the decorated resource.
 * 
 * The routes generated by this class will create a new instance of type T
 * each time a request comes in. Inversify is used to resolve an instance of type T
 * so it's important specificy a container in the constructor.
 * 
 * @throws Error if the resource is not decorated correctly.
 */
export class ResourceGenerator<T extends { [key: string]: any }> {
  private resource: { new (...args: any[]): T};
  private container: Container; 

  /**
   * @param resource the decorated resource of type T to generate
   * @param container an inversify container to use when resolving instances of type T.
   */
  constructor(resource: { new (...args: any[]): T}, container: Container) {
    this.resource = resource;
    this.container = container;
  }

  private getMetadataByKey(key: string): any {
    return Reflect.getMetadata(key, this.resource.prototype);
  }

  private getMetadataKeys(): string[] {
    return Reflect.getMetadataKeys(this.resource.prototype);
  }

  private wrapResource(route: ResourceRouteMetadata): ResourceHandler {
    switch (route.resourceType) {
      case ResourceType.API: 
        return apiHandler(route, this.resource, this.container);
        break;
      case ResourceType.TEMPLATE:
        return templateHandler(route, this.resource, this.container);
        break;
      case ResourceType.FILE:
        throw new Error('File render types not supported yet');
        break;
      default:
        throw new Error('Unexecpted render type');
    }
  }

  /**
   * Generates an express router that represents the resource defined by type T
   */
  generate(): express.Router {
    const routeKeys = this
      .getMetadataKeys()
      .filter((md: string) => md.startsWith('route-'));

    const resourceName = this.resource.name;

    const genVersion = this.getMetadataByKey('resource-generator-version');
    if (!genVersion) {
      throw Error(`${resourceName} is missing the resource decorator. Please check that the class has the decorator on it`);
    }
    else if (genVersion != 'v1') {
      throw Error(`${resourceName} was generated with an incompatible version of the resource-generator. Expected v1 and got ${genVersion}`);
    }

    console.log(`Generating resource: ${resourceName}`);

    let basePath: string | null | undefined = this.getMetadataByKey('base-path');
    if (basePath) {
      console.log(`    base path: ${basePath}`);
    }
    else {
      basePath = '';
    }

    const router = express.Router();
    //const resourceMiddleware: ResourceHandler[] = this.getMetadataByKey('resource-middleware');

    for (const key of routeKeys) {
      const route:ResourceRouteMetadata = this.getMetadataByKey(key);
      const fullPath = `${basePath}${route.path}`;

      console.log(`    adding route: ${route.resourceType} ${route.method.toUpperCase()} ${fullPath}`);

      /** 
       * 
       * middelware will stack like this per route
       * 
       * | JSON Body parser           | <- If applicable to route
       * | Resource level Middleware  |
       * | Route level Middeleware    |
       * | Gereanted resource Wrapper | <- Always the last function in the chain for a route
       * 
       */ 
      const middleware: ResourceHandler[] = [pinoMiddleware];

      if (route.resourceType == ResourceType.API) {
       // Coercing the type express.json middleware here into the ResourceHandler type
       // this should be ok as the singatures match. ResourceRequest is just a normal Express Request.
        middleware.push(express.json() as ResourceHandler);
      }

      /*
      if (resourceMiddleware) {
        middleware.push(...resourceMiddleware);
      }
      */

      if (!route.resourceRenderer) {
        // Get default ResourceRenderer for this resourceType if none is passed in.
        // This will likely be the the normal case.
        route.resourceRenderer = getDefaultRenderer(route.resourceType);
      }

      const wrapper: ResourceHandler = this.wrapResource(route);
      middleware.push(wrapper);

      router[route.method](fullPath, ...middleware);
    }

    return router;
  }
}